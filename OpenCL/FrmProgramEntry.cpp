#include "FrmProgramEntry.h"


const struct ProgramEntry FFT2D={"FFT2D",
	"#define PI (3.1415926f)\n"
	"#ifdef QC_OPT\n"
	"__kernel void FFT2DRadix2_P0( const int width, __global const float2* pInArray,\n"
	"__global float2* pOutArray, const int m)\n"
	"{\n"
	"int i = get_global_id(0)<<1;\n"
	"int t = get_global_size(0)<<1;\n"
	"int row = get_global_id(1);\n"
	"int startOffset = mul24(row, width);\n"
	"float8 u;\n"
	"u.s0145 = *(__global float4*)&pInArray[startOffset + i];\n"
	"u.s2367 = *(__global float4*)&pInArray[startOffset + i + t];\n"
	"u.s0123 = (float4)(u.s01 + u.s23, u.s01 - u.s23);\n"
	"int j = (i << 3) + (i >> (m - 3));\n"
	"pOutArray[startOffset + (j & (width-1)) ] = u.s01;\n"
	"pOutArray[startOffset + ((j + 4) & (width-1)) ] = u.s23;\n"
	"u.s4567 = (float4)(u.s45 + u.s67, u.s45 - u.s67);\n"
	"j += 8;\n"
	"pOutArray[startOffset + (j & (width-1)) ] = u.s45;\n"
	"pOutArray[startOffset + ((j + 4) & (width-1)) ] = u.s67;\n"
	"}\n"

	"inline float2 twiddleit(const float2 u, const int k, const int p, const float alpha)\n"
	"{\n"
	"float2 twiddle;\n"
	"float2 uTwiddled;\n"
	"twiddle.x = native_cos(alpha);\n"
	"twiddle.y = native_sin(alpha);\n"
	"uTwiddled.x = u.x * twiddle.x - u.y * twiddle.y;\n"
	"uTwiddled.y = u.x * twiddle.y + u.y * twiddle.x;\n"
	"return uTwiddled;\n"
	"}\n"

	"__kernel void FFT2DRadix4( const int width, const int p, __global const float2* pInArray,\n"
	"__global float2* pOutArray, const float oneOverN, const int m, const int sign, const float oneOverP)\n"
	"{\n"
	"int i = get_global_id(0);\n"
	"int row = get_global_id(1);\n"
	"int startOffset = mul24(row, width);\n"
	"int t = get_global_size(0);\n"
	"int k = i & ( p - 1 );\n"
	"float8 u;\n"
	"if(p == 1){\n"
	"u.s01 = pInArray[startOffset + i];\n"
	"u.s23 = pInArray[startOffset + i + t];\n"
	"u.s45 = pInArray[startOffset + mad24(2, t, i)];\n"
	"u.s67 = pInArray[startOffset + mad24(3, t, i)];\n"
	"}\n"
	"else{\n"
	"u = *(__global float8*)&pInArray[startOffset + (i<<2)];\n"
	"float alpha = sign * k * oneOverP;\n"
	"u.s23 = twiddleit(u.s23, k, p, alpha * 1.5707963);\n"
	"u.s45 = twiddleit(u.s45, k, p, alpha * PI);\n"
	"u.s67 = twiddleit(u.s67, k, p, alpha * 4.7123889);\n"	
	"}\n"
	"{\n"
	"float2 v0, v1, v2, v3;\n"
	"v0 = u.s01 + u.s45;\n"
	"v1 = u.s23 + u.s67;\n"
	"v2 = u.s01 - u.s45;\n"
	"v3.x = u.s3 - u.s7;\n"
	"v3.y = u.s6 - u.s2;\n"
	"v3 *= -sign;\n"
	"u.s01 = v0 + v1;\n"
	"u.s45 = v0 - v1;\n"
	"u.s23 = v2 + v3;\n"
	" u.s67 = v2 - v3;\n"
	"}\n"
	"if(p == t){\n"
	"pOutArray[startOffset + i] = u.s01 * oneOverN;\n"
	"pOutArray[startOffset + i + t] = u.s23 * oneOverN;\n"
	"pOutArray[startOffset + mad24(2, t, i)] = u.s45 * oneOverN;\n"
	"pOutArray[startOffset + mad24(3, t, i)] = u.s67 * oneOverN;\n"
	"}\n"
	"else{\n"
	"int j = (i << 4) + (i >> (m - 4)) - mul24(12, k);\n"
	"pOutArray[startOffset + (j & (width-1)) ] = u.s01;\n"
	"pOutArray[startOffset + ((j + (p << 2)) & (width-1)) ] = u.s23;\n"
	"pOutArray[startOffset + ((j + (p << 3)) & (width-1)) ] = u.s45;\n"
	"pOutArray[startOffset + ((j + mul24(3, p<<2)) & (width-1)) ] = u.s67;\n"
	"}\n"
	"}\n"

	"__kernel void MatrixTranspose(const uint rows, const uint cols, __global float2* matrix, __global float2* matrixTranspose)\n"
	"{\n"
	"const uint i = get_global_id(0)<<1;\n"
	"const uint j = get_global_id(1)<<1;\n"
	"float4 temp = *(__global float4*)&matrix[mad24(j, cols, i)];\n"
	"float4 temp1 = *(__global float4*)&matrix[mad24(j, cols, i) + cols];\n"
	"*(__global float4*)&matrixTranspose[mad24(i, rows, j)] = (float4)(temp.s01, temp1.s01);\n"
	"*(__global float4*)&matrixTranspose[mad24(i, rows, j) + rows] = (float4)(temp.s23, temp1.s23);\n"
	"}\n"
	"#endif\n"

	, "d91d5e7d7c63952c08769030655a5c90"};

const struct ProgramEntry simpleConvolution={"SimpleConvolution",
	"__kernel void simpleConvolution(__global  float* output,\n"
	"__global  float* input, __global  float* mask, const uint2 inputDimensions, const uint2 maskDimensions)\n"
	"{\n"
	"uint tid  = get_global_id(0);\n"
	"uint width  = inputDimensions.x;\n"
	"uint height = inputDimensions.y;\n"
	"uint x = tid%width;\n"
	"uint y = tid/width;\n"
	"uint maskWidth  = maskDimensions.x;\n"
	"uint maskHeight = maskDimensions.y;\n"
	"uint vstep = (maskWidth  -1)/2;\n"
	"uint hstep = (maskHeight -1)/2;\n"
	"uint left    = (x           <  vstep) ? 0         : (x - vstep);\n"
	"uint right   = ((x + vstep) >= width) ? width - 1 : (x + vstep);\n"
	"uint top     = (y           <  hstep) ? 0         : (y - hstep);\n"
	"uint bottom  = ((y + hstep) >= height)? height - 1: (y + hstep);\n"
	"float sumFX = 0;\n"
	"for(uint i = left; i <= right; ++i)\n"
	"for(uint j = top ; j <= bottom; ++j){\n"
	"uint maskIndex = (j - (y - hstep)) * maskWidth  + (i - (x - vstep));\n"
	"uint index     = j                 * width      + i;\n"
	"sumFX += (input[index] * mask[maskIndex]);}\n"
	"sumFX += 0.5f;\n"
	"output[tid] = sumFX;\n"
	"}\n"
	, "af755a2a32c7b43016576fecac43fa29"};